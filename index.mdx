---
title: "iolite Documentation"
description: "The technology platform for modern revenue cycle management"
---

<div style={{ display: 'flex', alignItems: 'center', gap: '16px', marginBottom: '8px' }}>
  <img src="/images/friendly-martian.png" alt="iolite Martian" width="64" />
  <span style={{ fontSize: '1.1rem' }}>
    Our platform ingests claims, remittances, and medical records via SFTP, processes them through a reactive data engine, and surfaces everything to users in real time.
  </span>
</div>

## How it works

<Columns cols={2}>
  <Card
    title="SFTP & Data Ingestion"
    icon="upload"
    href="/sftp/overview"
  >
    Customers upload EDI files, UCRN crosswalks, and medical records via SFTP. Files are automatically parsed and converted into structured entities.
  </Card>
  <Card
    title="Data Engine"
    icon="atom"
    href="/nebula/overview"
  >
    Our real-time Entity-Component-System engine stores, processes, and streams healthcare data to users and background services.
  </Card>
</Columns>

## Key concepts

<CardGroup cols={3}>
  <Card title="EDI" icon="file-lines" href="/sftp/edi">
    Electronic Data Interchange — standardized healthcare claim and payment files (837/835).
  </Card>
  <Card title="UCRN" icon="link" href="/sftp/ucrn">
    Universal Claim Record Number — crosswalk files that link account numbers to claim numbers.
  </Card>
  <Card title="Accounts" icon="folder-open" href="/sftp/accounts">
    Patient billing accounts that group claims, payments, and medical records together.
  </Card>
</CardGroup>

## Data flow

<Steps>
  <Step title="Ingest">
    Customer uploads a file via SFTP. It lands in cloud storage.
  </Step>
  <Step title="Parse">
    A file processor validates the path, routes by folder type (EDI, UCRN, MedicalRecords), and parses the file into structured data.
  </Step>
  <Step title="Persist">
    Parsed data is written to our data engine as entities. An immutable checkpoint is created for every change.
  </Step>
  <Step title="Fan out">
    Changes propagate in real time via two paths:
    - **WebSocket → Users** — fire-and-forget push to our UI layer
    - **Message queue → Services** — durable delivery to background services for further processing
  </Step>
</Steps>
